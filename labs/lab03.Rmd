---
title: "Lab 3"
author: "Sydney Stitt"
date: "Math 241, Week 3"
output:
  pdf_document
urlcolor: blue
---

```{r setup, include=FALSE}
# Do not modify this chunk.
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)


```

```{r}
libs <- c('tidyverse','knitr','viridis', 'mosaic','mosaicData','babynames', 'Lahman','nycflights13','rnoaa')
for(l in libs){
  if(!require(l,character.only = TRUE, quietly = TRUE)){
    message( sprintf('Did not have the required package << %s >> installed. Downloading now ... ',l))
    install.packages(l) 
  }
  library(l, character.only = TRUE, quietly = TRUE)
}

```



## Due: Friday, February 16th at 8:30am

## Goals of this lab

1. Practice creating functions.
1. Practice refactoring your code to make it better!  Therefore for each problem, make sure to test your functions.


### Problem 1: Subset that R Object

Here are the R objects we will use in this problem (`dats`, `pdxTreesSmall` and `ht`).    

```{r}
library(pdxTrees)
library(mosaicData)

pdxTrees <- get_pdxTrees_parks()
# Creating the objects
dats <- list(pdxTrees  = head(pdxTrees),
             Births2015 = head(Births2015),
             HELPrct = head(HELPrct), 
             sets = c("pdxTrees", "Births2015", 
                      "HELPrct"))

pdxTreesSmall  <- head(pdxTrees)

ht <- head(pdxTrees$Tree_Height, n = 15)

```

a. What are the classes of `dats`, `pdxTreesSmall` and `ht`?

`dats` is a list, 
`pdxTreesSmall` is a dataframe. 
`ht` is numeric.

b. Find the 10th, 11th, and 12th values of `ht`.

The 10th value of `ht` is 112.
The 11th value of `ht` is 112.
The 12th value of `ht` is 48.

c. Provide the `Species` column of `pdxTrees` as a data frame with one column.
```{r}
pdxTrees_species_df <- select(pdxTrees, Species)
```

d. Provide the `Species` column of `pdxTrees` as a character vector.
```{r}
pdxTrees_species_chr <- head(pdxTrees$Species)
as.character(pdxTrees_species_chr)
```

e. Provide code that gives us the second entry in `sets` from `dats`.
```{r}
dats$sets[2]
```

f. Subset `pdxTreesSmall` to only `Douglas-fir` and then provide the `DBH` and `Condition` of the 4th `Douglas-fir` in the dataset.  (Feel free to mix in some `tidyverse` code if you would like to.)
```{r}
pdxTreesSmall <- filter(pdxTreesSmall, Common_Name == "Douglas-Fir")
pdxTreesSmall$DBH[4]
pdxTreesSmall$Condition[4]
```



### Problem 2: Function Creation

Figure out what the following code does and then turn it into a function. For your new function, do the following:

* Test it.
* Provide default values (when appropriate).
* Use clear names for the function and arguments.
* Make sure to appropriately handle missingness.
* Generalize it by allowing the user to specify a confidence level.
* Check the inputs and stop the function if the user provides inappropriate values.


```{r}
library(pdxTrees)
thing1 <- length(pdxTrees$DBH)
thing2 <- mean(pdxTrees$DBH)
thing3 <- sd(pdxTrees$DBH)/sqrt(thing1)
thing4 <- qt(p = .975, df = thing1 - 1)
thing5 <- thing2 - thing4*thing3
thing6 <- thing2 + thing4*thing3
```

```{r}
# Confidence interval function
confidence_interval <- function(x, ci) {
  if (is.numeric(x) && is.numeric(ci)) {
  sample_size <- length(x)
  avg <- mean(x)
  standard_error <- sd(x)/sqrt(sample_size)
  t_score <- qt(p = ci, df = sample_size - 1)
  ci_lower_limit <- avg - t_score*standard_error
  ci_upper_limit <- avg + t_score*standard_error
  return(list(sample_size = sample_size,
              avg = avg,
              standard_error = standard_error,
              t_score = t_score,
              ci_lower_limit = ci_lower_limit,
              ci_upper_limit = ci_upper_limit))
  }
  else {
    stop("x and ci must be a numeric vector, not a character vector")
  }
}
confidence_interval(pdxTrees$DBH, 0.975)
```


### Problem 3: Wrapper Function for your `ggplot`


While we (i.e. Math 241 students) all love the grammar of graphics, not everyone else does. So for this problem, we are going to practice creating wrapper functions for `ggplot2`.

Here's an example of a wrapper for a histogram.  Notice that I can't just list the variable name as an argument.  The issue has to do with how many of the `tidyverse` functions evaluate the arguments. Therefore we have to quote (`enquo()`) and then unquote (`!!`) the arguments.  (If you want to learn more, go [here](https://tidyeval.tidyverse.org/).)

```{r}
# Minimal viable product working code
ggplot(data = pdxTrees, mapping = aes(x = DBH)) +
  geom_histogram()

# Shorthand histogram function
histo_function <- function(data, x){
   x <- enquo(x)
  ggplot(data = data, mapping = aes(x = !!x)) +
    geom_histogram()
}

# Testing histo function
histo_function(pdxTrees, DBH)
```

a. Edit `histo()` so that the user can set 

* The number of bins
* The fill color for the bars
* The color outlining the bars

```{r}
# Edited version of histo function
histo_function <- function(data, x, bins = 30, fill_color = "blue", outline_color = "black"){
   x <- enquo(x)
  ggplot(data = data, mapping = aes(x = !!x)) +
    geom_histogram(bins = bins, fill = fill_color, color = outline_color)
}

# Testing histo function
histo_function(pdxTrees, DBH, bins = 20, fill_color="green", outline_color="red")
```

b. Write code to create a basic scatterplot with `ggplot2`. Then write and test a function to create a basic scatterplot.

```{r}
# Basic scatterplot code
ggplot(data = pdxTrees, aes(x = Tree_Height, y = Carbon_Storage_value)) +
  geom_point()
```

```{r}
# Function for basic scatterplot
scatter_function <- function(data, x, y){
   x <- enquo(x)
   y <- enquo(y)
  ggplot(data = data, mapping = aes(x = !!x, y = !!y)) +
    geom_point()
}

# Testing scatter function
scatter_function(pdxTrees, Tree_Height, Carbon_Storage_value)
```


c. Modify your scatterplot function to allow the user to ...

* Color the points by another variable.
* Set the transparency.

```{r}
# Function for basic scatterplot
scatter_function <- function(data, x, y, alpha = 0.5, color = Condition){
   x <- enquo(x)
   y <- enquo(y)
   color <- enquo(color)
  ggplot(data = data, mapping = aes(x = !!x, y = !!y, color = !!color)) +
    geom_point(alpha = alpha)
}

# Testing scatter function
scatter_function(pdxTrees, Tree_Height, Carbon_Storage_value, alpha = 0.9, color = Native)
```

d. Write and test a function for your favorite `ggplot2` graph.
```{r}
# Basic violin plot code
ggplot(data = pdxTrees, aes(x = Condition, y = Carbon_Storage_lb)) +
  geom_violin()
```

```{r}
# Function for basic violin plot
violin_function <- function(data, x, y){
   x <- enquo(x)
   y <- enquo(y)
  ggplot(data = data, mapping = aes(x = !!x, y = !!y)) +
    geom_violin()
}

#Testing violin function
violin_function(pdxTrees, Condition, Carbon_Storage_lb)
```

### Problem 4: Functioning `dplyr`


a. Take the following code and turn it into an R function to create a **conditional proportions** table.  Similar to `ggplot2`, you will need to quote and unquote the variable names.  Make sure to test your function!

```{r}
pdxTrees %>%
  count(Native, Condition) %>%
  group_by(Native) %>%
  mutate(prop = n/sum(n)) %>%
  ungroup()
```


```{r}
# Creating the conditional_prop_table function
conditional_prop_table <- function(data, var1, var2) {
  data %>% 
  count(!!enquo(var1), !!enquo(var2)) %>%
  group_by(!!enquo(var1)) %>%
  mutate(prop = n, na.rm = TRUE/sum(n, na.rm = TRUE)) %>%
  ungroup()
  }

# Testing the conditional_prop_table function 
result_conditional_function <- conditional_prop_table(pdxTrees, Native, Condition)
print(result_conditional_function)
```

b.  Write a function to compute the mean, median, sd, min, max, sample size, and number of missing values of a quantitative variable by the categories of another variable.  Make sure the output is a data frame (or tibble).  Don't forget to test your function.

```{r}
# Creating the summarize_function
summarize_function <- function(data, var1, var2) {
  var2 <- enquo(var2)
  var1 <- enquo(var1)
  data %>%
  group_by(!!var1) %>%
  summarize(avg <- mean(!!var2,na.rm = TRUE),
            median <- median(!!var2,na.rm = TRUE),
            sd <- sd(!!var2,na.rm = TRUE),
            min <- min(!!var2,na.rm = TRUE),
            max <- max(!!var2,na.rm = TRUE),
            sample_size <- length(!!var2),
            missing <- sum(is.na(!!var2)))
}

# Testing the summarize_function with Condition and Tree_Height variables
summarize_function(pdxTrees, Condition, Tree_Height)
```

### Problem 5: another `babynames` exercise

Write a function called grab_name that, when given a **name** ***and a year*** as an argument, returns the rows from the `babynames` data frame in the `babynames` package that match that name for that year (and returns an error if that name and year combination does not match any rows). Run the function once with the arguments **Ezekiel and 1883** and once with **Ezekiel and 1983**.

```{r, eval=TRUE}
# Creating the grab_name function
grab_name <- function(myname, myyear) {
if (is.element(myname, babynames$name) && is.element(myyear, babynames$year)) { 
  babynames %>%
  filter(name == myname) %>%
  filter(year ==  myyear) %>%
  return()
    }
  else {
    stop("Name and year combination not found in dataset")
  }
}

#Testing the grab_name function with Ezekiel and 1883 and Ezekiel and 1983
ezekiel_1883 <- grab_name("Ezekiel", "1883")
ezekiel_1983 <- grab_name("Ezekiel", "1983")
print(ezekiel_1883)
print(ezekiel_1983)
```